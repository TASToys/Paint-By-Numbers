<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Paint By Numbers</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            outline: 0;
            list-style: none;
            font-size: 16px;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }


        h1 {
            font-size: 2em;
            margin: 0.3em 0;
            width: 960px;
            margin: 0 auto;
        }

        #cv-container {
            width: 100%;
            text-align: center;
            margin-bottom: 20px;
        }

        #cv {
            margin: 0 auto;
            border: 1px solid #000;
        }

        input[type="text"], input[type="number"] {
            font-size: 0.9em;
            padding: 2px;
        }

        input[readonly] {
            background-color: #eee;
        }

        #container {
            width: 960px;
            margin: 0 auto;
        }

        #config {
            display: inline-block;
            width: 60%;
            margin-bottom: 100px;
        }



            #config ul li {
                line-height: 2.2em;
            }

                #config ul li > label {
                    display: inline-block;
                    width: 200px;
                }

                #config ul li .info {
                    color: #666;
                    font-size: 0.8em;
                    line-height: 1.0em;
                    margin-bottom: 0.4em;
                }

                    #config ul li .info em {
                        font-size: 100%;
                    }

                #config ul li input[type="number"], #config ul li input[type="color"] {
                    width: 60px;
                }

                #config ul li input[type="text"] {
                    width: 350px;
                }



        #sceneHistory-container {
            display: inline-block;
            width: 39%;
            vertical-align: top;
        }

            #sceneHistory-container label {
                display: inline-block;
                width: 80px;
            }

            #sceneHistory-container input[type="text"] {
                width: 290px;
            }

        #sceneHistory {
        }

            #sceneHistory p {
                font-size: 0.9em;
                margin-top: 0.4em;
            }

        label.switch {
            font-size: 22px;
            display: inline-block;
            height: 1em !important;
            width: 2.7em !important;
            cursor: pointer;
            vertical-align: middle;
        }

            label.switch input[type="checkbox"] {
                display: none;
            }

            label.switch span {
                display: block;
                height: 100%;
                border: solid 1px #888;
                border-radius: 4px;
                background-color: red;
                position: relative;
                transition: background 0.1s linear;
            }

                label.switch span:before {
                    box-sizing: border-box;
                    content: "";
                    display: inline-block;
                    height: 100%;
                    width: 50%;
                    top: 0%;
                    left: 0%;
                    position: absolute;
                    background-color: white;
                    border-radius: 3px;
                    transition: left 0.1s ease;
                    border: solid 1px #ccc;
                }

            label.switch input:checked + span {
                background-color: green;
            }

                label.switch input:checked + span:before {
                    left: 50%;
                }

        .input-small {
            width: 150px !important;
        }



        body.obs #cv-container {
            text-align: left;
        }

        body.obs #cv {
            border: 0;
        }

        body.obs h1 {
            display: none;
        }

        body.obs #container {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Paint By Numbers</h1>
    <div id="cv-container">
        <canvas id="cv"></canvas>
    </div>
    <div id="container">
        <div id="config">
            <ul>
                <li>
                    <label>Canvas size:</label>
                    X: <input type="number" value="1280" id="txtCanvasX" min="1" max="3840" />
                    Y: <input type="number" value="720" id="txtCanvasY" min="1" max="2160" />
                </li>
                <li>
                    <label>Background color:</label>
                    <input type="color" id="colBackgroundColor" value="#ffffff" />
                </li>
                <li>
                    <label>Grid lines enabled:</label>
                    <label class="switch">
                        <input type="checkbox" id="cbShowGrid" checked />
                        <span></span>
                    </label>
                </li>
                <li>
                    <label>Grid size/color:</label>
                    <input type="number" value="4" id="txtGridSize" min="1" max="100" />
                    <input type="color" value="#c0c0c0" id="colGridColor" />
                </li>
                <li>
                    <label>Grid line underlap</label>
                    <label class="switch">
                        <input type="checkbox" id="cbGridUnderlap" checked />
                        <span></span>
                    </label>
                    <p class="info">If enabled, the drawn cells will overlap the grid lines, resulting in full coverage</p>
                </li>
                <li>
                    <label>Emphasis lines enabled:</label>
                    <label class="switch">
                        <input type="checkbox" id="cbShowGridEmphasis" checked />
                        <span></span>
                    </label>
                </li>
                <li>
                    <label>Emphasis frequency/color:</label>
                    <input type="number" value="10" id="txtEmphasisFrequency" />
                    <input type="color" value="#a0a0a0" id="colEmphasisColor" />
                    <p class="info">Optional color every <em>n</em> cells</p>
                </li>
                <li>
                    <label>Twitch channels:</label>
                    <input type="text" id="txtChannels" />
                    <p class="info">Comma-separated list of Twitch channels to connect to</p>
                </li>
                <li>
                    <label>Config name:</label>
                    <input type="text" id="txtName" />
                    <p class="info">If a name is set, then this config can be loaded with only the name</p>
                </li>
                <li>
                    <label>Bot name:</label>
                    <input type="text" id="txtBotName" />
                </li>
                <li>
                    <label>OAuth code:</label>
                    <input type="text" id="txtOAuthCode" />
                    <p class="info">If PBN will be listening to a room, or needs the ability to talk back, a login must be provided</p>
                </li>
            </ul>
            <hr />
            <ul>
                <li>
                    <label>Grid size:</label>
                    <input type="text" id="txtGridSizeOutput" class="input-small" readonly />
                </li>
                <li>
                    <label>Effective canvas size:</label>
                    X: <input type="number" value="1280" id="txtEffectiveX" readonly />
                    Y: <input type="number" value="720" id="txtEffectiveY" readonly />
                </li>
                <li>
                    <label>OBS Browser Source URL:</label>
                    <input type="text" id="txtURL" readonly />
                </li>
                <li>
                    <label>Management URL:</label>
                    <input type="text" id="txtManageURL" readonly />
                </li>
            </ul>
        </div>

        <div id="sceneHistory-container">
            <p><label>Chat:</label><input type="text" id="txtChat" /></p>
            <div id="sceneHistory"></div>
        </div>
    </div>

    <script>

        //#region utility functions

        function Color(r, g, b) {
            this.R = r;
            this.G = g;
            this.B = b;
        }

        function Point(x, y) {
            this.X = x;
            this.Y = y;
        }

        function GetColorFromHex(hex) {
            hex = hex.replace('#', '');
            if (hex.length == 6)
                return new Color(
                    parseInt(hex.substring(0, 2), 16),
                    parseInt(hex.substring(2, 4), 16),
                    parseInt(hex.substring(4, 6), 16)
                );
            else if (hex.length == 3)
                return new Color(
                    parseInt(hex.substring(0, 1) + hex.substring(0, 1), 16),
                    parseInt(hex.substring(1, 2) + hex.substring(1, 2), 16),
                    parseInt(hex.substring(2, 3) + hex.substring(2, 3), 16)
                );

        }

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        function Create2DArray(rows) {
            var arr = [];
            for (var i = 0; i < rows; i++)
                arr[i] = [];
            return arr;
        }

        function RandomInt(min, max) {
            return min + Math.floor(Math.random() * (max - min));
        }

        function PaintEvent() {
            this.X = 0;
            this.Y = 0;
            this.User = '';
            this.Timestamp = 0;
            this.Color = '';
        }

        function CellState() {
            this.u = '';
            this.t = 0;
            this.c = '';
        }

        function AnimationFrame() {
            this.EmoteID = -1;
            this.Countdown = 0;
            this.Duration = 30;
            this.DrawOrders = [];
        }

        function PendingDraw() {
            this.X = 0;
            this.Y = 0;
            this.Color = '';
            this.Delay = 0;
        }

        //#endregion


        //#region global vars

        var colors = {
            "dust": "#b2996e",
            "tea": "#65ab7c",
            "cement": "#a5a391",
            "spruce": "#0a5f38",
            "booger": "#9bb53c",
            "bland": "#afa88b",
            "desert": "#ccad60",
            "purply": "#983fb2",
            "liliac": "#c48efd",
            "custard": "#fffd78",
            "manilla": "#fffa86",
            "bruise": "#7e4071",
            "azul": "#1d5dec",
            "darkgreen": "#054907",
            "lichen": "#8fb67b",
            "burple": "#6832e3",
            "butterscotch": "#fdb147",
            "toupe": "#c7ac7d",
            "squash": "#f2ab15",
            "cinnamon": "#ac4f06",
            "cocoa": "#875f42",
            "orangeish": "#fd8d49",
            "swamp": "#698339",
            "camo": "#7f8f4e",
            "fern": "#63a950",
            "sapphire": "#2138ab",
            "parchment": "#fefcaf",
            "straw": "#fcf679",
            "terracota": "#cb6843",
            "creme": "#ffffb6",
            "topaz": "#13bbaf",
            "wintergreen": "#20f986",
            "leather": "#ac7434",
            "hazel": "#8e7618",
            "canary": "#fdff63",
            "mushroom": "#ba9e88",
            "greenblue": "#23c48b",
            "carmine": "#9d0216",
            "grapefruit": "#fd5956",
            "ice": "#d6fffa",
            "algae": "#54ac68",
            "pinky": "#fc86aa",
            "darkblue": "#030764",
            "rosa": "#fe86a4",
            "lipstick": "#d5174e",
            "claret": "#680018",
            "dandelion": "#fedf08",
            "orangered": "#fe420f",
            "ruby": "#ca0147",
            "dark": "#1b2431",
            "putty": "#beae8a",
            "saffron": "#feb209",
            "twilight": "#4e518b",
            "bluegrey": "#85a3b2",
            "petrol": "#005f6a",
            "royal": "#0c1793",
            "butter": "#ffff81",
            "orangish": "#fc824a",
            "leaf": "#71aa34",
            "sunflower": "#ffc512",
            "velvet": "#750851",
            "carnation": "#fd798f",
            "wisteria": "#a87dc2",
            "pale": "#fff9d0",
            "greyblue": "#77a1b5",
            "purpley": "#8756e4",
            "diarrhea": "#9f8303",
            "viridian": "#1e9167",
            "bile": "#b5c306",
            "spearmint": "#1ef876",
            "yellowgreen": "#bbf90f",
            "heather": "#a484ac",
            "mango": "#ffa62b",
            "shamrock": "#01b44c",
            "bubblegum": "#ff6cb5",
            "lightgreen": "#76ff7b",
            "merlot": "#730039",
            "apple": "#6ecb3c",
            "heliotrope": "#d94ff5",
            "dusk": "#4e5481",
            "kiwi": "#9cef43",
            "seaweed": "#18d17b",
            "iris": "#6258c4",
            "perrywinkle": "#8f8ce7",
            "tealish": "#24bca8",
            "pear": "#cbf85f",
            "sandy": "#f1da7a",
            "greyish": "#a8a495",
            "banana": "#ffff7e",
            "tomato": "#ef4026",
            "sea": "#3c9992",
            "buff": "#fef69e",
            "fawn": "#cfaf7b",
            "amethyst": "#9b5fc0",
            "chestnut": "#742802",
            "pea": "#a4bf20",
            "stone": "#ada587",
            "earth": "#a2653e",
            "asparagus": "#77ab56",
            "blueberry": "#464196",
            "caramel": "#af6f09",
            "ocher": "#bf9b0c",
            "lightblue": "#7bc8f6",
            "golden": "#f5bf03",
            "gunmetal": "#536267",
            "cherry": "#cf0234",
            "midnight": "#03012d",
            "blood": "#770001",
            "berry": "#990f4b",
            "poo": "#8f7303",
            "snot": "#acbb0d",
            "drab": "#828344",
            "rouge": "#ab1239",
            "wheat": "#fbdd7e",
            "watermelon": "#fd4659",
            "mulberry": "#920a4e",
            "auburn": "#9a3001",
            "celadon": "#befdb7",
            "celery": "#c1fd95",
            "strawberry": "#fb2943",
            "copper": "#b66325",
            "ivory": "#ffffcb",
            "adobe": "#bd6c48",
            "barney": "#ac1db8",
            "ocre": "#c69c04",
            "maize": "#f4d054",
            "sandstone": "#c9ae74",
            "camel": "#c69f59",
            "marine": "#042e60",
            "sepia": "#985e2b",
            "coffee": "#a6814c",
            "mocha": "#9d7651",
            "ecru": "#feffca",
            "purpleish": "#98568d",
            "cranberry": "#9e003a",
            "melon": "#ff7855",
            "silver": "#c5c9c7",
            "amber": "#feb308",
            "vermillion": "#f4320c",
            "russet": "#a13905",
            "pine": "#2b5d34",
            "bluish": "#2976bb",
            "bronze": "#a87900",
            "shit": "#7f5f00",
            "dirt": "#8a6e45",
            "pistachio": "#c0fa8b",
            "yellowish": "#faee66",
            "bordeaux": "#7b002c",
            "ocean": "#017b92",
            "marigold": "#fcc006",
            "steel": "#738595",
            "blush": "#f29e8e",
            "lemon": "#fdff52",
            "cerise": "#de0c62",
            "apricot": "#ffb16d",
            "blurple": "#5539cc",
            "bluegreen": "#017a79",
            "forest": "#0b5509",
            "ultramarine": "#2000b1",
            "purplish": "#94568c",
            "reddish": "#c44240",
            "avocado": "#90b134",
            "umber": "#b26400",
            "poop": "#7f5e00",
            "eggshell": "#ffffd4",
            "denim": "#3b638c",
            "evergreen": "#05472a",
            "aubergine": "#3d0734",
            "mahogany": "#4a0100",
            "mud": "#735c12",
            "brownish": "#9c6d57",
            "clay": "#b66a50",
            "jade": "#1fa774",
            "emerald": "#01a049",
            "sky": "#82cafc",
            "orchid": "#c875c4",
            "raspberry": "#b00149",
            "tangerine": "#ff9408",
            "pumpkin": "#e17701",
            "charcoal": "#343837",
            "cornflower": "#6a79f7",
            "chocolate": "#3d1c02",
            "scarlet": "#be0119",
            "sienna": "#a9561e",
            "terracotta": "#ca6641",
            "grass": "#5cac2d",
            "moss": "#769958",
            "vomit": "#a2a415",
            "pinkish": "#d46a7e",
            "cobalt": "#1e488f",
            "wine": "#80013f",
            "azure": "#069af3",
            "grape": "#6c3461",
            "greenish": "#40a368",
            "coral": "#fc5a50",
            "cream": "#ffffc2",
            "brick": "#a03623",
            "sage": "#87ae73",
            "white": "#ffffff",
            "eggplant": "#380835",
            "puke": "#a5a502",
            "fuchsia": "#ed0dd9",
            "crimson": "#8c000f",
            "ochre": "#bf9005",
            "cerulean": "#0485d1",
            "rust": "#a83c09",
            "slate": "#516572",
            "goldenrod": "#fac205",
            "seafoam": "#80f9ad",
            "puce": "#a57e52",
            "sand": "#e2ca76",
            "mint": "#9ffeb0",
            "chartreuse": "#c1f80a",
            "taupe": "#b9a281",
            "khaki": "#aaa662",
            "burgundy": "#610023",
            "plum": "#580f41",
            "gold": "#dbb40c",
            "glod": "#ffdf00",
            "tasbot": "#7a5b07",
            "navy": "#01153e",
            "aquamarine": "#04d8b2",
            "rose": "#cf6275",
            "mustard": "#ceb301",
            "indigo": "#380282",
            "lime": "#aaff32",
            "periwinkle": "#8e82fe",
            "peach": "#ffb07c",
            "black": "#000000",
            "lilac": "#cea2fd",
            "beige": "#e6daa6",
            "salmon": "#ff796c",
            "olive": "#6e750e",
            "maroon": "#650021",
            "mauve": "#ae7181",
            "aqua": "#13eac9",
            "cyan": "#00ffff",
            "tan": "#d1b26f",
            "lavender": "#c79fef",
            "turquoise": "#06c2ac",
            "violet": "#9a0eea",
            "grey": "#929591",
            "yellow": "#ffff14",
            "magenta": "#c20078",
            "orange": "#f97306",
            "teal": "#029386",
            "red": "#e50000",
            "brown": "#653700",
            "pink": "#ff81c0",
            "blue": "#0343df",
            "green": "#15b01a",
            "purple": "#7e1e9c"

        };

        var
            canvas, //internal canvas object
            ctx, //canvas context
            imageData,
            effectiveWidth = 0,
            effectiveHeight = 0, //actual canvas dimensions calculated from grid settings

            settingsTimerId = -1, //timer variable for UI delay on update
            isLoading = false, //switch to ignore input change events while loading

            queryList = {}, //name-indexed list of query string parameters
            sceneHistory = [], //history of draw orders given
            state = [], //current state of the image
            lastState = [],
            animationState = [], //int counts of any pending animations
            pendingDraws = [], //
            redrawTimer = 0, //keeps track of how long a re/sub redraw will take, so new draw orders can be offset correctly

            emotes = [], //array of already-loaded emotes

            pendingAnimations = [],

            canTalk = false,

            debug = false; //switch to log detailed info to console

        var config = {
            CanvasWidth: 1280,
            CanvasHeight: 720,
            BackgroundColor: '#ffffff',
            GridEnabled: true,
            GridSize: 4,
            GridColor: '#c0c0c0',
            GridUnderlap: false,
            GridEmphasisEnabled: true,
            GridEmphasisFrequency: 10,
            GridEmphasisColor: '#a0a0a0',
            GridWidth: 0,
            GridHeight: 0,
            TwitchChannels: [],
            Name: 'default',
            BotName: '',
            OAuthCode: ''
        };

        //#endregion


        //#region websocket

        var ws;

        function Connect() {

            ws = new WebSocket('wss://irc-ws.chat.twitch.tv');

            ws.onopen = function open(e) {
                if (debug)
                    console.log('Websocket opening: ', e);

                this.send('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership');
                //this.send('CAP REQ :twitch.tv/commands');

                if (canTalk) {
                    this.send('PASS oauth:' + config.OAuthCode);
                    this.send('NICK ' + config.BotName);
                }
                else {
                    this.send('NICK justinfan' + Math.floor(Math.random() * 999999));
                }


                //this.send('JOIN #199.9.253.119');
                for (var i = 0; i < config.TwitchChannels.length; i++) {
                    this.send('JOIN #' + config.TwitchChannels[i].toLowerCase());
                }
            }

            //show raw data
            ws.onmessage = function (msgEvent) {
                var lines = msgEvent.data.split('\r\n');
                for (var l = 0; l < lines.length; l++) {
                    var line = lines[l].trim();
                    if (line == '')
                        continue;

                    var lineParts = line.split(' ');

                    if (debug)
                        console.log(line);

                    if (lineParts[0] == 'PING') {
                        ws.send('PONG ' + line.split(':')[1]);
                    }
                    else if (lineParts[2] == 'PRIVMSG') {
                        //console.log('hi');
                        var parts = line.split('PRIVMSG');
                        var preparts = parts[0].split(';');
                        var user = preparts[preparts.length - 1].split(':')[1].split('!')[0];

                        parts[1] = parts[1].trim();
                        var cIdx = parts[1].indexOf(':');
                        if (parts[1].indexOf('#chatrooms:') == 0) {
                            cIdx = parts[1].indexOf(':', cIdx + 15);
                        }
                        var msg = parts[1].substring(cIdx + 1);

                        var hasEmote = false,
                            emoteIdx = -1,
                            isCommand = false,
                            userIsSub = false;

                        for (var i = 0; i < preparts.length; i++) {

                            if (preparts[i].indexOf('@badges=') == 0) {

                                if (preparts[i].split('=')[1].indexOf('subscriber') > -1) {
                                    userIsSub = true;
                                }

                                if (preparts[i].split('=')[1].indexOf('broadcaster') > -1 || user == 'timeshifter08') {

                                    if (msg.trim().toLowerCase() == '!reload') {
                                        isCommand = true;

                                        if (queryList['seed'] != null) {
                                            config = JSON.parse(atob(queryList["seed"]));
                                            SaveSettings();
                                            LoadSettings('pbn-' + config.Name);
                                        }
                                    }

                                    if (msg.trim().toLowerCase() == '!clear') {
                                        isCommand = true;
                                        for (var k in localStorage) {
                                            if (k.indexOf('pbn-') == 0) {
                                                localStorage.removeItem(k);
                                            }
                                        }

                                        Init();

                                    }

                                    if (msg.trim().toLowerCase() == '!redraw') {

                                        GenerateRedraw(-1);

                                    }


                                }
                            }


                            if (preparts[i].indexOf('emotes=') == 0 && preparts[i].trim() != 'emotes=') {
                                var emoteList = preparts[i].split('=')[1].split('/');
                                emoteIdx = parseInt(emoteList[0].split(':')[0], 10);
                                hasEmote = true;

                            }

                            if (preparts[i].indexOf('bits=') == 0) {
                                var bitCount = parseInt(preparts[i].split('=')[1], 10);
                                if (bitCount >= 100)
                                    GenerateRedraw(-1);

                            }
                        }

                        if (!isCommand) {

                            if (hasEmote)
                                ParseMessage('manual', 'emote ' + emoteIdx);
                            else
                                ParseMessage(user, msg, userIsSub);

                        }

                    }

                    else if (lineParts[2] == 'USERNOTICE') {

                        var isSub = -1;

                        var msgParts = lineParts[0].split(';');

                        for (var i = 0; i < msgParts.length; i++) {

                            if (msgParts[i] == 'msg-id=sub') {
                                isSub = 0;
                                break;
                            }
                            else if (msgParts[i] == 'msg-id=resub') {
                                isSub = 1;
                                break;
                            }
                            else if (msgParts[i] == 'msg-id=subgift') {
                                isSub = 2;
                                break;
                            }

                        }

                        if (isSub >= 0) {


                            GenerateRedraw(isSub);

                        }

                    }

                }
            }

            ws.onerror = function (e) {
                if (debug)
                    console.log('Websocket error: ', e);
            }

            ws.onclose = function (e) {
                if (debug)
                    console.log('Websocket closed: ', e);
                setTimeout(function () {
                    Connect();
                }, 1000);
            }
        }



        function GenerateRedraw(subImg) {

            if (redrawTimer > 0)
                return;

            var duration = 60 * 10;

            sceneHistory.sort((a, b) => a.Timestamp - b.Timestamp);

           // var gridStatus = Create2DArray(config.GridWidth);

            for (var x = 0; x < config.GridWidth; x++) {
                for (var y = 0; y < config.GridHeight; y++) {
                   // gridStatus[x][y] = 0;
                    var p = new PendingDraw();
                    p.X = x;
                    p.Y = y;
                    p.Color = config.BackgroundColor;
                    p.Delay = 0;
                    pendingDraws.push(p);
                }
            }

            var lim = sceneHistory.length;

            //one pixel per frame
            if (lim <= duration) {
                redrawTimer = lim + 1;

                for (var i = 0; i < lim; i++) {
                    var h = sceneHistory[i];
                    var p = new PendingDraw();
                    p.X = h.X;
                    p.Y = h.Y;
                    p.Color = h.Color;
                    p.Delay = i + 1;
                    pendingDraws.push(p);
                   // gridStatus[h.X][h.Y] = 1;
                }

            }
            else {
                var ppt = duration / lim,
                    currDelay = 1;
                redrawTimer = duration + 1;

                for (var i = 0; i < lim; i++) {
                    var h = sceneHistory[i];
                    var p = new PendingDraw();
                    p.X = h.X;
                    p.Y = h.Y;
                    p.Color = h.Color;
                    p.Delay = Math.floor(currDelay);

                    pendingDraws.push(p);
                    currDelay = 1 + ((1 + i) * ppt);
                  //  gridStatus[h.X][h.Y] = 1;
                }
            }



        }

        /*
        cheer/emote msg:

        @badges=broadcaster/1;
        color=#1E90FF;
        display-name=timeshifter08;
        emote-only=1;
        emotes=25:0-4/41:6-13;
        id=6e46ba37-29a0-4ab3-9ca2-c07451e985f8;mod=0;room-id=61927669;subscriber=0;tmi-sent-ts=1516225093401;turbo=0;user-id=61927669;user-type= :timeshifter08!timeshifter08@timeshifter08.tmi.twitch.tv PRIVMSG #timeshifter08 :Kappa Kreygasm


        @badges=bits/1;
        bits=1;
        color=#1E90FF;
        display-name=timeshifter08;
        emotes=41:7-14;
        id=c8ee75e9-197a-4d05-8741-221363eecbfc;
        mod=0;
        room-id=70067886;
        subscriber=0;
        tmi-sent-ts=1511968477261;
        turbo=0;
        user-id=61927669;
        user-type=
        :timeshifter08!timeshifter08@timeshifter08.tmi.twitch.tv PRIVMSG #dwangoac :cheer1 Kreygasm


        @badges=moderator/1,subscriber/0,bits/5000;
        color=#FF4500;
        display-name=MediaMagnet;
        emotes=;
        id=98a76159-e2f6-4080-bb5e-910cd54a6467;
        mod=1;
        room-id=70067886;
        sent-ts=1509252055763;
        subscriber=1;
        tmi-sent-ts=1509252067701;
        turbo=0;
        user-id=111485954;
        user-type=mod:mediamagnet!mediamagnet@mediamagnet.tmi.twitch.tv PRIVMSG #dwangoac :oh nice

        */

        function GetChatObject(str) {
            var ret = {};
            var mainParts = str.split('PRIVMSG');
            var parts = mainParts[0].split(';');

            for (var i = 0; i < parts.length; i++) {
                var subparts = parts[i].split('=');
                var k = subparts[0].trim();
                subparts.shift();
                ret[k] = subparts.join('=').trim();
            }
            return ret;
        }

        //#endregion


        //#region init

        (function () {
            InitUI();
            Init();

        })();

        function InitUI() {

            canvas = document.getElementById('cv');

            //bind UI update events
            txtCanvasX.oninput = UpdateSettingsTrigger;
            txtCanvasY.oninput = UpdateSettingsTrigger;
            cbShowGrid.onchange = UpdateSettingsTrigger;
            txtGridSize.oninput = UpdateSettingsTrigger;
            colGridColor.onchange = UpdateSettingsTrigger;
            cbGridUnderlap.onchange = UpdateSettingsTrigger;
            cbShowGridEmphasis.onchange = UpdateSettingsTrigger;
            txtEmphasisFrequency.oninput = UpdateSettingsTrigger;
            colEmphasisColor.onchange = UpdateSettingsTrigger;
            colBackgroundColor.onchange = UpdateSettingsTrigger;
            txtChannels.oninput = UpdateSettingsTrigger;
            txtName.oninput = UpdateSettingsTrigger;
            txtBotName.oninput = UpdateSettingsTrigger;
            txtOAuthCode.oninput = UpdateSettingsTrigger;
            txtChat.onkeydown = ManualChat;

            //create queryList array
            if (window.location.search) {
                var query = window.location.search;
                var queryParts = query.substring(1).split('&');
                for (var i = 0; i < queryParts.length; i++) {
                    var parts = queryParts[i].split('=');
                    queryList[parts[0].trim()] = parts[1].trim();

                }
            }

            if (window.obsstudio || queryList["mode"] == "obs") {
                document.getElementsByTagName('body')[0].classList.add('obs');
            }
        }

        function Init() {

            for (var k in localStorage) {
                if (k.indexOf('pbn') == 0 && k.indexOf('-history') > -1) {
                    localStorage.removeItem(k);
                }
            }

            //load if possible
            if (queryList["config"]) {
                if (localStorage.getItem(queryList["config"]) != null) {
                    LoadSettings(queryList["config"]);
                }
                else {
                    //config specified, but doesn't exist
                    if (queryList["seed"]) {
                        config = JSON.parse(atob(queryList["seed"]));
                        SaveSettings();
                        LoadSettings('pbn-' + config.Name);
                    }
                    else {
                        //specified config doesn't exist, no seed, init defaults
                        UpdateSettings();
                    }
                }
            }
            else {
                if (queryList["seed"]) {
                    config = JSON.parse(atob(queryList["seed"]));
                    SaveSettings();
                    LoadSettings('pbn-' + config.Name);
                }
                else if (localStorage.getItem('pbn-default') != null) {
                    LoadSettings('pbn-default');
                }
                else {
                    //specified config doesn't exist, no seed, init defaults
                    UpdateSettings();
                }
            }

            if (state.length < config.GridWidth) {
                for (var i = 0; i < config.GridWidth; i++) {
                    if (!state[i]) {
                        state[i] = [];
                        lastState[i] = [];
                    }
                }
            }


            var tmpList = [];

            for (var x = 0; x < state.length; x++) {
                for (var y = 0; y < state[0].length; y++) {
                    if (state[x][y]) {

                        if (state[x][y].u != 'start') {
                            var h = new PaintEvent();
                            h.X = x;
                            h.Y = y;
                            h.Color = state[x][y].c;
                            h.User = state[x][y].u;
                            h.Timestamp = state[x][y].t;
                            tmpList.push(h);
                        }
                    }
                    else {
                        var s = new CellState();
                        s.u = 'start';
                        s.c = config.BackgroundColor;
                        s.t = (new Date()).getTime();
                        state[x][y] = s;
                        lastState[x][y] = s;
                    }
                }
            }

            tmpList.sort((a, b) => { return a.Timestamp > b.Timestamp ? 1 : -1; });

            for (var i = 0; i < tmpList.length; i++) {
                sceneHistory.push(tmpList[i]);
            }


            if (config.TwitchChannels.length > 0 && ws == null) {
                Connect();
            }

            AnimationTick();
        }

        //#endregion


        //#region save & load stuff

        function UpdateSettingsTrigger() {
            if (!isLoading) {
                clearTimeout(settingsTimerId);
                settingsTimerId = setTimeout(UpdateSettings, 500);
            }
        }

        function UpdateSettings() {

            config.CanvasWidth = parseInt(txtCanvasX.value, 10);
            config.CanvasHeight = parseInt(txtCanvasY.value, 10);
            config.BackgroundColor = colBackgroundColor.value;
            config.GridEnabled = cbShowGrid.checked;
            config.GridSize = parseInt(txtGridSize.value, 10);
            config.GridColor = colGridColor.value;
            config.GridUnderlap = cbGridUnderlap.checked;
            config.GridEmphasisEnabled = cbShowGridEmphasis.checked;
            config.GridEmphasisFrequency = parseInt(txtEmphasisFrequency.value, 10);
            config.GridEmphasisColor = colEmphasisColor.value;
            config.BotName = txtBotName.value;
            config.OAuthCode = txtOAuthCode.value;

            if (txtChannels.value.trim() != '')
                config.TwitchChannels = txtChannels.value.split(',').map(function (x) { return x.trim(); });
            else
                config.TwitchChannels = [];

            if (txtName.value.trim() != '')
                config.Name = txtName.value.trim();
            else
                config.Name = 'default';

            if (config.BotName != '' && config.OAuthCode != '')
                canTalk = true;

            UpdateURLs();

            SaveSettings();

            DrawGrid();
        }

        function SaveSettings() {
            localStorage.setItem('pbn-' + config.Name, JSON.stringify(config));
            if (debug)
                console.log('settings saved');
        }

        function LoadSettings(configName) {
            isLoading = true;

            //TODO
            config = JSON.parse(localStorage.getItem(configName));
            if (debug)
                console.log(config);


            txtCanvasX.value = config.CanvasWidth;
            txtCanvasY.value = config.CanvasHeight;
            cbShowGrid.checked = config.GridEnabled;
            txtGridSize.value = config.GridSize;
            colGridColor.value = config.GridColor;
            cbGridUnderlap.checked = config.GridUnderlap;
            cbShowGridEmphasis.checked = config.GridEmphasisEnabled;
            txtEmphasisFrequency.value = config.GridEmphasisFrequency;
            colEmphasisColor.value = config.GridEmphasisColor;
            txtChannels.value = config.TwitchChannels.join(', ');
            txtName.value = config.Name;
            txtBotName.value = config.BotName;
            txtOAuthCode.value = config.OAuthCode;

            if (config.BackgroundColor)
                colBackgroundColor.value = config.BackgroundColor;
            else
                config.BackgroundColor = colBackgroundColor.value;

            if (config.BotName != '' && config.OAuthCode != '')
                canTalk = true;


            UpdateURLs();

            isLoading = false;
            DrawGrid();

            //if (localStorage.getItem(configName + '-history') != null)
            //    sceneHistory = JSON.parse(localStorage.getItem(configName + '-history'));
            if (localStorage.getItem(configName + '-state') != null) {
                state = JSON.parse(localStorage.getItem(configName + '-state'));
                lastState = JSON.parse(localStorage.getItem(configName + '-state'));

                for (var x = 0; x < state.length; x++) {
                    for (var y = 0; y < state[0].length; y++) {
                        if (state[x][y].u != 'start') {
                            DrawCell(x, y, state[x][y].c);
                        }
                    }
                }

            }

        }

        function UpdateURLs() {
            txtURL.value = window.location.href.replace(window.location.search, '') + '?config=pbn-' + config.Name + '&mode=obs&seed=' + btoa(JSON.stringify(config));
            txtManageURL.value = window.location.href.replace(window.location.search, '') + '?config=pbn-' + config.Name;
            //txtSeedURL.value = window.location.href.replace(window.location.search, '') + '?seed=' + btoa(JSON.stringify(config));
        }

        //#endregion


        //#region drawing code

        function DrawGrid() {
            var gridDimX, gridDimY;

            if (config.GridEnabled && !config.GridUnderlap) {
                gridDimX = Math.floor((config.CanvasWidth + 1) / (config.GridSize + 1));
                effectiveWidth = (gridDimX * (config.GridSize + 1)) - 1;

                gridDimY = Math.floor((config.CanvasHeight + 1) / (config.GridSize + 1));
                effectiveHeight = (gridDimY * (config.GridSize + 1)) - 1;
            }
            else { //underlap and no grid at all have the same grid size calculation
                gridDimX = Math.floor(config.CanvasWidth / config.GridSize);
                effectiveWidth = gridDimX * config.GridSize;

                gridDimY = Math.floor(config.CanvasHeight / config.GridSize);
                effectiveHeight = gridDimY * config.GridSize;
            }

            config.GridWidth = gridDimX;
            config.GridHeight = gridDimY;

            state = Create2DArray(gridDimX);
            lastState = Create2DArray(gridDimX);
            animationState = Create2DArray(gridDimX);



            for (var x = 0; x < gridDimX; x++) {
                for (var y = 0; y < gridDimY; y++) {
                    var s = new CellState();
                    s.u = 'start';
                    s.c = config.BackgroundColor;
                    s.t = (new Date()).getTime();
                    state[x][y] = s;
                    lastState[x][y] = s;

                    animationState[x][y] = 0;
                }
            }

            canvas.width = effectiveWidth;
            canvas.height = effectiveHeight;

            txtEffectiveX.value = effectiveWidth;
            txtEffectiveY.value = effectiveHeight;

            txtGridSizeOutput.value = (gridDimX) + 'x' + (gridDimY);

            ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            //ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = config.BackgroundColor;
            ctx.fillRect(0, 0, config.CanvasWidth, config.CanvasHeight);

            if (config.GridEnabled) {
                var gridDrawSize = config.GridSize + (config.GridUnderlap ? 0 : 1);
                ctx.strokeStyle = config.GridColor;
                ctx.lineWidth = 1;

                for (var x = 1; x < gridDimX; x++) {
                    ctx.beginPath();
                    ctx.moveTo((x * gridDrawSize) - 0.5, 0);
                    ctx.lineTo((x * gridDrawSize) - 0.5, canvas.height);
                    ctx.stroke();
                }
                for (var y = 1; y < gridDimY; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, (y * gridDrawSize) - 0.5);
                    ctx.lineTo(canvas.width, (y * gridDrawSize) - 0.5);
                    ctx.stroke();
                }

                if (config.GridEmphasisEnabled) {
                    ctx.strokeStyle = config.GridEmphasisColor;

                    for (var x = 1; x < (gridDimX / config.GridEmphasisFrequency); x++) {
                        ctx.beginPath();
                        ctx.moveTo((x * config.GridEmphasisFrequency * gridDrawSize) - 0.5, 0);
                        ctx.lineTo((x * config.GridEmphasisFrequency * gridDrawSize) - 0.5, canvas.height);
                        ctx.stroke();
                    }

                    for (var y = 1; y < (gridDimY / config.GridEmphasisFrequency); y++) {
                        ctx.beginPath();
                        ctx.moveTo(0, (y * config.GridEmphasisFrequency * gridDrawSize) - 0.5);
                        ctx.lineTo(canvas.width, (y * config.GridEmphasisFrequency * gridDrawSize) - 0.5);
                        ctx.stroke();
                    }
                }
            }
        }


        function DrawCell(x, y, c) {
            ctx.fillStyle = c;
            var gridDrawSize = config.GridSize + (config.GridUnderlap ? 0 : 1);
            ctx.fillRect(x * gridDrawSize, y * gridDrawSize, config.GridSize, config.GridSize);
        }


        //#endregion


        //#region chat input handling

        function ManualChat(e) {
            if (e.keyCode == 13) {
                ParseMessage('manual', txtChat.value);
                txtChat.value = '';
            }
        }

        function ParseMessage(user, text, userIsSub) {
            text = text.trim().toLowerCase();
            var c, coords;



            if (text.indexOf('rgb') == 0) {
                var parts = text.replace('rgb(', '').split(')');
                var colParts = parts[0].split(',');
                c = rgbToHex(parseInt(colParts[0], 10), parseInt(colParts[1], 10), parseInt(colParts[2], 10));
                coords = parts[1];
            }
            else if (text.indexOf('#') == 0) {
                var parts = text.split(' ');
                if (parts[0].length == 7)
                    c = parts[0];
                else if (parts[0].length == 4)
                    c = '#' + parts[0].substring(1, 2) + parts[0].substring(1, 2) + parts[0].substring(2, 3) + parts[0].substring(2, 3) + parts[0].substring(3, 4) + parts[0].substring(3, 4);
                parts.shift();
                coords = parts.join('');

            }
            else {
                var parts = text.split(' ');
                if (colors[parts[0]] != undefined) {
                    c = colors[parts[0]];
                    parts.shift();
                    coords = parts.join('');
                }
            }

            if (user == 'manual') {
                if (text.indexOf('emote') == 0) {
                    var parts = text.split(' ');
                    var idx = parseInt(parts[1], 10);
                    if (emotes[idx] == null) {
                        var i = new Image();
                        i.onload = OnEmoteLoaded;
                        i.crossOrigin = 'anonymous';
                        i.src = 'https://static-cdn.jtvnw.net/emoticons/v1/' + parts[1] + '/1.0';
                        emotes[parseInt(parts[1], 10)] = {};
                        emotes[parseInt(parts[1], 10)].img = i;
                        emotes[parseInt(parts[1], 10)].canvas = document.createElement('canvas');
                    }
                    else {
                        CreateAnimation(idx);
                    }

                }
            }

            if (c != undefined) {

                var coordSets = coords.split(';');



                for (var i = 0; i < coordSets.length; i++) {



                    var coordParts = coordSets[i].split(',');

                    if (coordParts.length == 2) {

                        var p = new PendingDraw();
                        p.X = parseInt(coordParts[0].trim(), 10) - 1;
                        p.Y = parseInt(coordParts[1].trim(), 10) - 1;
                        p.Color = c;
                        p.Delay = i + redrawTimer;
                        pendingDraws.push(p);

                        //DrawCell(parseInt(coordParts[0].trim(), 10) - 1, parseInt(coordParts[1].trim(), 10) - 1, c);

                        if (!document.getElementsByTagName('body')[0].classList.contains('obs')) {
                            var str = '<p>' + user + ": " + c + " " + coordParts[0] + "," + coordParts[1] + '</p>';
                            document.getElementById('sceneHistory').insertAdjacentHTML('afterbegin', str);
                        }


                        var h = new PaintEvent();
                        h.X = parseInt(coordParts[0], 10) - 1;
                        h.Y = parseInt(coordParts[1], 10) - 1;
                        h.Color = c;
                        h.User = user;
                        h.Timestamp = (new Date()).getTime();
                        sceneHistory.push(h);
                        //localStorage.setItem('pbn-' + config.Name + '-history', JSON.stringify(sceneHistory));

                        lastState[h.X][h.Y].u = state[h.X][h.Y].u;
                        lastState[h.X][h.Y].t = state[h.X][h.Y].t;
                        lastState[h.X][h.Y].c = state[h.X][h.Y].c;

                        state[h.X][h.Y].u = h.User;
                        state[h.X][h.Y].t = h.Timestamp;
                        state[h.X][h.Y].c = h.Color;

                    }

                }
                localStorage.setItem('pbn-' + config.Name + '-state', JSON.stringify(state));
            }





        }


        //#endregion



        function OnEmoteLoaded(e) {
            // console.log(e);
            var parts;
            if (e.path) {
                parts = e.path[0].src.split('/');
            }
            else {
                parts = e.target.src.split('/');
            }

            var idx = parseInt(parts[5], 10);
            emotes[idx].canvas.width = emotes[idx].img.width;
            emotes[idx].canvas.height = emotes[idx].img.height;
            emotes[idx].canvas.src = emotes[idx].img;
            emotes[idx].ctx = emotes[idx].canvas.getContext('2d');
            emotes[idx].ctx.drawImage(emotes[idx].img, 0, 0);
            emotes[idx].data = emotes[idx].ctx.getImageData(0, 0, emotes[idx].canvas.width, emotes[idx].canvas.height);
            emotes[idx].Points = [];

            for (var x = 0; x < emotes[idx].img.width; x++) {
                for (var y = 0; y < emotes[idx].img.height; y++) {
                    if (IsPixelOpaque(emotes[idx].data, x, y)) {
                        var o = {
                            X: x,
                            Y: y,
                            Color: GetPixelFromImageData(emotes[idx].data, x, y)
                        };
                        emotes[idx].Points.push(o);
                    }
                }
            }

            CreateAnimation(idx);
        }

        var animations = [
            //draw "slide-in" left to right
            function (origin, emoteIdx) {
                for (var x = 0; x < emotes[emoteIdx].img.width; x++) {
                    var anim = new AnimationFrame();
                    anim.Countdown = x * 2;
                    anim.Duration = 90;
                    anim.EmoteID = emoteIdx;

                    for (var y = 0; y < emotes[emoteIdx].img.height; y++) {
                        if (IsPixelOpaque(emotes[emoteIdx].data, x, y)) {
                            var h = new PaintEvent();
                            h.X = origin.X + x;
                            h.Y = origin.Y + y;
                            h.Color = GetPixelFromImageData(emotes[emoteIdx].data, x, y);
                            if (h.X >= 0 && h.X < config.GridWidth && h.Y >= 0 && h.Y < config.GridHeight) {
                                anim.DrawOrders.push(h);
                               // animationState[h.X][h.Y]++;
                            }
                        }
                    }

                    pendingAnimations.push(anim);
                }
            },

            //draw "slide-in" right to left
            function (origin, emoteIdx) {
                for (var x = emotes[emoteIdx].img.width-1; x >=0; x--) {
                    var anim = new AnimationFrame();
                    anim.Countdown = (emotes[emoteIdx].img.width-1-x) * 2;
                    anim.Duration = 90;
                    anim.EmoteID = emoteIdx;

                    for (var y = 0; y < emotes[emoteIdx].img.height; y++) {
                        if (IsPixelOpaque(emotes[emoteIdx].data, x, y)) {
                            var h = new PaintEvent();
                            h.X = origin.X + x;
                            h.Y = origin.Y + y;
                            h.Color = GetPixelFromImageData(emotes[emoteIdx].data, x, y);
                            if (h.X >= 0 && h.X < config.GridWidth && h.Y >= 0 && h.Y < config.GridHeight) {
                                anim.DrawOrders.push(h);
                               // animationState[h.X][h.Y]++;
                            }

                        }
                    }

                    pendingAnimations.push(anim);
                }
            },

            //draw "slide-in" top to bottom
            function (origin, emoteIdx) {
                for (var y = 0; y < emotes[emoteIdx].img.height; y++) {
                    var anim = new AnimationFrame();
                    anim.Countdown = y * 2;
                    anim.Duration = 90;
                    anim.EmoteID = emoteIdx;

                    for (var x = 0; x < emotes[emoteIdx].img.width; x++) {
                        if (IsPixelOpaque(emotes[emoteIdx].data, x, y)) {
                            var h = new PaintEvent();
                            h.X = origin.X + x;
                            h.Y = origin.Y + y;
                            h.Color = GetPixelFromImageData(emotes[emoteIdx].data, x, y);
                            if (h.X >= 0 && h.X < config.GridWidth && h.Y >= 0 && h.Y < config.GridHeight) {
                                anim.DrawOrders.push(h);
                                //animationState[h.X][h.Y]++;
                            }
                        }
                    }

                    pendingAnimations.push(anim);
                }
            },


            //draw "slide-in" bottom to top
            function (origin, emoteIdx) {
                for (var y = emotes[emoteIdx].img.height - 1; y >= 0; y--) {
                    var anim = new AnimationFrame();
                    anim.Countdown = (emotes[emoteIdx].img.height - 1 - y) * 2;
                    anim.Duration = 90;
                    anim.EmoteID = emoteIdx;

                    for (var x = 0; x < emotes[emoteIdx].img.width; x++) {
                        if (IsPixelOpaque(emotes[emoteIdx].data, x, y)) {
                            var h = new PaintEvent();
                            h.X = origin.X + x;
                            h.Y = origin.Y + y;
                            h.Color = GetPixelFromImageData(emotes[emoteIdx].data, x, y);
                            if (h.X >= 0 && h.X < config.GridWidth && h.Y >= 0 && h.Y < config.GridHeight) {
                                anim.DrawOrders.push(h);
                                //animationState[h.X][h.Y]++;
                            }
                        }
                    }

                    pendingAnimations.push(anim);
                }
            },



            //random draw-in
            function (origin, emoteIdx) {
                var drawPts = [];

                for (var x = 0; x < emotes[emoteIdx].img.width; x++) {
                    for (var y = 0; y < emotes[emoteIdx].img.height; y++) {
                        if (IsPixelOpaque(emotes[emoteIdx].data, x, y)) {
                            drawPts.push(new Point(x, y));
                        }
                    }
                }

                var frameCounter = 0, its=45;

                var ptsPer = Math.ceil(drawPts.length / its);



                for (var frame = 0; frame < its; frame++) {
                    for (var i = 0; i < ptsPer; i++) {
                        if (drawPts.length > 0) {
                            var idx = RandomInt(0, drawPts.length);

                            var anim = new AnimationFrame();
                            anim.Countdown = frame; //Math.floor(frameCounter / 5);
                            anim.Duration = 90;
                            anim.EmoteID = emoteIdx;

                            try {
                                var h = new PaintEvent();
                                h.X = drawPts[idx].X;
                                h.Y = drawPts[idx].Y;
                                h.Color = GetPixelFromImageData(emotes[emoteIdx].data, h.X, h.Y);
                                anim.DrawOrders.push(h);
                                //animationState[h.X][h.Y]++;
                                pendingAnimations.push(anim);
                            }
                            catch (e) {
                                console.log(e);
                            }


                            frameCounter++;
                            drawPts.splice(idx, 1);
                        }
                    }

                }

            },

            //horizontal slices
            //function (origin, emoteIdx) {
            //    var tempList = Array.apply(null, { length: emotes[emoteIdx].img.height }).map(Number.call, Number);


            //    var frameCounter = 0;
            //    while (tempList.length > 0) {
            //        var rndIdx = RandomInt(0, tempList.length);
            //        var y = tmpList[rndIdx];

            //        var dir = y % 2 == 0 ? 1 : -1;







            //        tempList.splice(rndIdx, 1);
            //    }


            //}
        ]

        function CreateAnimation(emoteIdx) {

            var origin = new Point(RandomInt(0, config.GridWidth - emotes[emoteIdx].img.width - 1), RandomInt(0, config.GridHeight - emotes[emoteIdx].img.height - 1)),
                i = RandomInt(0, animations.length);
            //i = 5;
            animations[i](origin, emoteIdx);
        }

        function IsPixelOpaque(data, x, y) {
            var idx = (data.width * y + x) * 4;
            return data.data[idx + 3] > 0;
        }

        function GetPixelFromImageData(data, x, y) {
            var idx = (data.width * y + x) * 4;
            return rgbToHex(data.data[idx], data.data[idx + 1], data.data[idx + 2]);
        }

        function AnimationTick() {
            var removeList = [];
            if (redrawTimer > 0)
                redrawTimer--;

            for (var i = 0; i < pendingDraws.length; i++) {

                if (pendingDraws[i].Delay <= 0) {
                    removeList.push(i);
                    DrawCell(pendingDraws[i].X, pendingDraws[i].Y, pendingDraws[i].Color);

                }
                else {

                    pendingDraws[i].Delay--;

                }

            }

            pendingDraws = pendingDraws.filter((_, i) => !removeList.includes(i));

            removeList = [];

            for (var i = 0; i < pendingAnimations.length; i++) {




                if (pendingAnimations[i].Countdown == 0) {
                    pendingAnimations[i].DrawOrders.forEach(function (x) {
                        DrawCell(x.X, x.Y, x.Color);
                        animationState[x.X][x.Y]++;
                    });

                }
                else if (pendingAnimations[i].Countdown <= -pendingAnimations[i].Duration) { //undraw
                    // pendingAnimations[i].DrawOrders.forEach(function (pt) {

                    for (var j = 0; j < pendingAnimations[i].DrawOrders.length; j++) {
                        var pt = pendingAnimations[i].DrawOrders[j];

                        animationState[pt.X][pt.Y]--;

                        if (animationState[pt.X][pt.Y] == 0) {
                            if (state[pt.X][pt.Y].u == 'start') {
                                DrawCell(pt.X, pt.Y, state[pt.X][pt.Y].c);
                            }


                            if (config.GridUnderlap && config.GridEnabled && state[pt.X][pt.Y].u == 'start') {
                                ctx.strokeStyle = config.GridColor;

                                var x = pt.X * (config.GridSize + (config.GridUnderlap ? 0 : 1)) - 0.5,
                                    y = pt.Y * (config.GridSize + (config.GridUnderlap ? 0 : 1)) - 0.5,
                                    size = config.GridSize + (config.GridUnderlap ? 0 : 1);
                                ctx.beginPath();
                                ctx.moveTo(x, y + size);
                                ctx.lineTo(x + size, y + size);
                                ctx.lineTo(x + size, y);
                                ctx.stroke();


                                if (config.GridEmphasisEnabled) {
                                    ctx.strokeStyle = config.GridEmphasisColor;

                                    if ((pt.X + 1) % config.GridEmphasisFrequency == 0) {
                                        ctx.beginPath();
                                        ctx.moveTo(x + size, y);
                                        ctx.lineTo(x + size, y + size);
                                        ctx.stroke();
                                    }

                                    if ((pt.Y + 1) % config.GridEmphasisFrequency == 0) {
                                        ctx.beginPath();
                                        ctx.moveTo(x, y + size);
                                        ctx.lineTo(x + size, y + size);
                                        ctx.stroke();
                                    }


                                }


                            }

                            if (state[pt.X][pt.Y].u != 'start') {
                                DrawCell(pt.X, pt.Y, state[pt.X][pt.Y].c);
                            }

                        }


                    }

                    //});
                    removeList.push(i);
                }

                pendingAnimations[i].Countdown--;




            }

            pendingAnimations = pendingAnimations.filter((_, i) => !removeList.includes(i));

            requestAnimationFrame(AnimationTick);
        }


    </script>
</body>
</html>
